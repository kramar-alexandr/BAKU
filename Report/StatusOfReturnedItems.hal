external procedure HT2Per(Date,Date,var string);
external procedure HTLocations(string, string, var string);
external function string 100 GetBrand(string);

SetLangMode(LangRussian,"RUS",0);






//функция для возврата данных в материнскую запись (в индекс соответсутвующим Location)
//если изменения были после исследуемого в отчете периода
procedure ReturnChangesBackToTheMotherRecord(record ItemHistVc IHr,integer index ,var array val remainQty, var array val remainCost,var array val remainCostCurncy)
begin
		
				remainQty[index] = remainQty[index] - IHr.Qty;
				remainCost[index] = remainCost[index] + IHr.TotCostPrice;
				remainCostCurncy[index] = remainCostCurncy[index] + IHr.TotCostPriceCurncy; 
end;






//Рекурсивная функция для поиска остатков на складе
//Принимается запись ItemHistVc о возврате товара из сч/фактуры 
//функция суммирует остатки  всех записей, по соответствующим складам, для которых входящая запись была источником
//в Hansa 6.4 нет возможности нормально работать с var vector register, поэтому накопление данных сделано в массивах

procedure GetRemainQty(record ItemHistVc IHr,vector integer allLocations ,date endDate,var array val remainQty, var array val remainCost,var array val remainCostCurncy)		//Edit----------------------Dima  19.05.2016
begin
	record ItemHistVc IHnext,IHtemp,IHmother;
	boolean TrHs,TrHs2;
	integer index;
	
	IHnext.Source = IHr.SerNr;
	TrHs = true;
	
	While(LoopKey("Source",IHnext,1,TrHs)) begin
		if (IHnext.Source!=IHr.SerNr) then begin TrHs=false; end;
	
		if (TrHs) then begin				
		
				//Перемещение (StockMovVc) отображается в ItemHistVc двумя записями списание/поступление
				//запись поступление не содержит источник, --> необходимо найти 
				//соответствующее поступление для соответствующего списания, и дальше продолжить
				//рекурсивный поиск
				
				if (IHnext.FileName == "StockMovVc") then begin
					IHtemp.FileName = "StockMovVc";
					IHtemp.TransNr = IHnext.TransNr;
					IHtemp.Row = IHnext.Row;
					TrHs2 = true;
					While(LoopKey("FNTransNr",IHtemp,3,TrHs2)) begin
						if (IHtemp.Row != IHnext.Row or IHtemp.TransNr != IHnext.TransNr) then begin TrHs2=false; end;
						if (IHtemp.TransDate>endDate and IHtemp.Qty < 0 and TrHs2) then begin  //откат изменений, если они были позже endDate
							index = allLocations[IHtemp.Location];
							ReturnChangesBackToTheMotherRecord(IHtemp,index,remainQty,remainCost,remainCostCurncy);
						end;						
						if (IHtemp.Qty > 0 and TrHs2) then begin
							TrHs2 = false;
							IHnext = IHtemp;
						end;					
					end;
				end;
				
				GetRemainQty(IHnext,allLocations,endDate,remainQty,remainCost,remainCostCurncy);

		end;
	end;
	
	
	//чтобы избежать пролистывания цикла по массиву,
	//вектор 	allLocations хранит индекс каждого склада
		index = allLocations[IHr.Location];
		
		remainQty[index] = remainQty[index] + IHr.RemQty;
		remainCost[index] = remainCost[index] + IHr.RemCostPrice;
		remainCostCurncy[index] = remainCostCurncy[index] + IHr.RemCostPriceCurncy;
		
		//откат изменений, не попадающих в период
		if (IHr.TransDate>endDate) then begin
			index = allLocations[IHr.Location];
			ReturnChangesBackToTheMotherRecord(IHr,index,remainQty,remainCost,remainCostCurncy);
		end;		


return;
end;



procedure ClearMyArray(var array val arr)
begin
integer i;

	for(i=0;i<arr.length;i=i+1) begin
		arr[i] = 0;
	end;
end;





//отчет показывает кол-во оставшихся товаров (среди возвращенных товаров)

global procedure StatusOfReturnedItemsRn(record RcVc RepSpec)
begin
  record IVVc IVr,IV1r;
  row IVVc IVrw;
	record ItemHistVc IHr;
  longint count,totals,tick1,tick2;
  integer i,rw,rwcnt;
  date startDate,endDate;
  boolean TrHs,testf,TrHs2;
  boolean remainsFounded;
  string 20 location;
  string 255 tstr;
  string 200 prevArtCode, brand;
  record LocationVc Locr;
  vector integer allLocations;
  vector string 100 getLocationByIndex;
  array val remainQty;
  array val remainCost;
  array val remainCostCurncy;

  
  count = 0;
  totals = 0;
  startDate = RepSpec.sStartDate;
  endDate = RepSpec.sEndDate;
  location = RepSpec.f3;

  
  i=0;
  //индексы для складов, чтобы избежать постоянного поиска в циклах
  While(LoopMain(Locr,1,true)) begin
		allLocations[Locr.Code] = i;
		getLocationByIndex[i] = Locr.Code;
		i = i + 1;
	end;

	  
  
  StartReportJob("Статус возвращенных товаров");
    rw = 1;
  	HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  	Header(rw,tstr,1);rw=rw+1;
  	HTLocations(location,location,tstr);
  	Header(rw,tstr,1);
  
  EndHeader;
  
  
	StartFormat(15);
		Outstring(20,0,"Сч/ф возврата",false);
		Outstring(80,0,"Код товара",false);
		Outstring(150,0,"Бренд",false);
		Outstring(200,0,"Склад",false);
		Outstring(275,0,"Кол-во",false);
		Outstring(330,0,"Себестоимость",false);
		Outstring(380,0,"Себестоимость в вал.",false);
		Outstring(440,0,"Валюта",false);
			
	EndFormat;  
	


  
  IHr.FileName = "IVVc";
  IHr.TransDate = startDate;
  TrHs = true;
  
  While(LoopKey("FNTransDate",IHr,2,TrHs)) begin
	  testf = true;
		if (IHr.FileName!="IVVc") then begin TrHs = false; testf = false; end;
		if (IHr.TransDate > endDate) then begin TrHs = false; testf = false; end;
		if (IHr.StockAffectf == 0) then begin testf = false; end;
		if (IHr.Qty < 0) then begin testf = false; end;
		
		if (testf) then begin
		
			ClearMyArray(remainQty);ClearMyArray(remainCost);			
			ClearMyArray(remainCostCurncy);
			
			 
			GetRemainQty(IHr,allLocations,endDate,remainQty,remainCost,remainCostCurncy);
			brand = "";
			remainsFounded = false;
			
			for(i=0;i<remainQty.length;i=i+1) begin
			
				if (remainQty[i] > 0) then begin				
					if((nonblank(location) and (location==getLocationByIndex[i])) or blank(location)) then begin 
						
						remainsFounded = true;
						if (blank(brand)) then begin 
								brand = GetBrand(IHr.ArtCode); 
						end;
													
						StartFormat(15);
							Outstring(20,0,IHr.TransNr,false);
							Outstring(80,0,IHr.ArtCode,false);
							Outstring(150,0,brand,false);
							Outstring(200,0,getLocationByIndex[i],false); // Склад остатка, не сч/ф
							Outstring(275,0,remainQty[i],false);
							Outstring(330,0,remainCost[i],false);
							Outstring(380,0,remainCostCurncy[i],false);
							Outstring(440,0,IHr.CurncyCode,false);			
						EndFormat;
					end;				
				end;

			end;
			
			

			
			if (remainsFounded) then begin
						IV1r.SerNr = IHr.TransNr;
						if (ReadFirstMain(IV1r,1,true)) then begin						
							EndFormat;
							Outstring(50,0,"Список сч/ф покупки:",false);
							Outstring(215,0,"Клиент",false);
							Outstring(250,0, IV1r.CustCode,false);
							Outstring(300,0, IV1r.Addr0,false);
							EndFormat;						
						
							IVr.CustCode = IV1r.CustCode;
							TrHs2 = true;
							While(LoopKey("CustCode",IVr,1,TrHs2)) begin
								if (IVr.CustCode != IV1r.CustCode) then begin TrHs2=false; end;
								if (TrHs2) then begin
									rwcnt = MatRowCnt(IVr);
									for(i=0;i<rwcnt;i=i+1) begin
										MatRowGet(IVr,i,IVrw);
										if (IVrw.stp==kInvoiceRowTypeNormal and IVrw.ArtCode==IHr.ArtCode and IVrw.Quant>0) then begin
											i = rwcnt;
											Outstring(130,0,IVr.SerNr,false);
										end;
									end;
								end;
							end;
							ResetLoop(IVr);
						end;			
			end;
			EndFormat;
			Gray_Divider(0,1);
			
			
		end; 
	end;  

 
  EndJob;
  



  
  
end;  